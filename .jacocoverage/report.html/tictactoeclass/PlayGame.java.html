<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PlayGame.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;TicTacToeClass&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">tictactoeclass</a> &gt; <span class="el_source">PlayGame.java</span></div><h1>PlayGame.java</h1><pre class="source lang-java linenums">package tictactoeclass;

import java.awt.Color;   // Needed for color blue, ToDo refactor &amp; color in UI

/**
 * PlayGame
 *   Everything needed to play a game &lt;br&gt;
 *   Creates two players (player1 and player2) &lt;br&gt;
 *   Creates TicTacToe board &lt;br&gt;
 * &lt;P&gt;
 * Constructor argument &lt;br&gt;
 *    Drop - dropbox used for message synch between gui thread and calling thread &lt;br&gt;
 * &lt;P&gt;
 * Designed so game can be played without the gui, using manual passing of moves &lt;br&gt;
 *   Needed for JUnit testing of game
 * &lt;P&gt;
 * @author lvall
 */
public class PlayGame {
            /*
         * Initialize objects Players &amp; Board
         */
<span class="fc" id="L23">        private Player player1 = new Player(Board.Symbols.X);</span>
<span class="fc" id="L24">        private Player player2 = new Player(Board.Symbols.O);</span>
<span class="fc" id="L25">        private Board board = new Board();</span>
        
        // testSleep - for auto testing, slowing game so board is visible
        //    propose to only allow setting in constructor (for now)
        //    zero is no delay
<span class="fc" id="L30">        private int testSleep = 0;</span>
        
        // drop used for synchronized message passing from UI
        // initial version - take synchronization handler from main
        //   ToDo: embed message synch in PlayGame class &amp; call as a forked thread
        private Drop drop; 
        private TicTacToeUI ui;
        


<span class="fc" id="L40">    PlayGame(Drop mainDropMessageSynch, int sleepValue) {</span>

<span class="fc" id="L42">        drop = mainDropMessageSynch;</span>
<span class="fc" id="L43">        board.setNextToPlay(player1);  // ToDo - option to configure starting player</span>
        
<span class="fc" id="L45">        testSleep = sleepValue;</span>
        
        // Initialize GUI, including button listeners
        // ToDo - overload constructor - accept argument specing no GUI
<span class="fc" id="L49">        ui = new TicTacToeUI(board, drop);</span>
<span class="fc" id="L50">        ui.setButtonActionListener();</span>

<span class="fc" id="L52">    }</span>
    
    PlayGame(Drop mainDropMessageSynch) {
<span class="fc" id="L55">        this (mainDropMessageSynch, 0);</span>
<span class="fc" id="L56">    }</span>
    
    /**
     *   playGame - process player move selection &lt;br&gt;
     *     called by actionListener on button click, or &lt;br&gt;
     *     by JUnit tests (bypassing main() ) &lt;br&gt;
     * @param row - row # of box selected 0-2 &lt;br&gt;
     * @param column - column # of box 0-2 &lt;br&gt;
     * &lt;P&gt;
     * PreCondition: nextToPlay (board instance) points to player entering current move &lt;br&gt;
     * PostCondition (if valid move): nextToPlay points to other player
     * &lt;P&gt;
     * validates move ... &lt;br&gt;
     * if valid &lt;br&gt;
     *   updates box in board class &lt;br&gt;
     *   checks win or draw on this move &lt;br&gt;
     *   toggles player and &lt;br&gt;
     *   updates user message display (win, draw, next to play, errors)
     * 
     */
    
    
    public void playGame(int row, int column) {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (board.isGameOver()) {</span>
<span class="nc" id="L80">            return;  // game over, do not process</span>
        }
<span class="fc" id="L82">        Move move = new Move(row,column,board.getNextToPlay().getPlayerSymbol());</span>
        // print move to console
<span class="fc" id="L84">        move.printMove();</span>
        
        // if invalid move - print to both console GUI
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (!board.isMoveValid(move)) {</span>
<span class="nc" id="L88">            ui.printUserError(&quot;Invalid move&quot;);</span>
<span class="nc" id="L89">            ui.printUserMessage(&quot;Invalid move&quot; + </span>
<span class="nc" id="L90">                    board.getNextToPlay().getPlayerName());</span>
<span class="nc" id="L91">            return;  // invalid move, let user repeat</span>
        }
        else {
<span class="fc" id="L94">            ui.drawBoard(board);  // draw text version of board b4 move</span>
<span class="fc" id="L95">            board.setBox(move);</span>
<span class="fc" id="L96">            Board.Symbols symbol = board.getNextToPlay().getPlayerSymbol();</span>
<span class="fc" id="L97">            ui.labelButton(row,column,symbol.name());</span>
<span class="fc" id="L98">            ui.drawBoard(board);  // draw text version after move</span>
        }
                    // check if winner or draw
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (board.isWinner (board.getNextToPlay().getPlayerSymbol())) {</span>
<span class="fc" id="L102">            System.out.println(&quot;Winner: &quot; + board.getNextToPlay().getPlayerName());</span>
<span class="fc" id="L103">            ui.printUserMessage(&quot;WINNER!: &quot; + board.getNextToPlay().getPlayerName());</span>
            
              // Board tracks winning boxes, query and change color
              //   should be a separate private method
              //   separate = isolates strategy to show winning boxes
<span class="fc" id="L108">            Move[] winningBoxes = board.getWinningBoxes();</span>
<span class="fc" id="L109">            ui.labelButton(winningBoxes[0].getRow(), winningBoxes[0].getColumn(), Color.blue);</span>
<span class="fc" id="L110">            ui.labelButton(winningBoxes[1].getRow(), winningBoxes[1].getColumn(), Color.blue);</span>
<span class="fc" id="L111">            ui.labelButton(winningBoxes[2].getRow(), winningBoxes[2].getColumn(), Color.blue);</span>
            
<span class="fc" id="L113">        }</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        else if (board.isDraw()) {</span>
<span class="nc" id="L115">            System.out.println(&quot;Draw&quot;);</span>
<span class="nc" id="L116">            ui.printUserMessage(&quot;It's a DRAW!&quot;);</span>
        }
        // no closing else - no winner, not a draw, keep playing

        // switch players &amp; display next turn
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (board.getNextToPlay() == player1)</span>
<span class="fc" id="L122">            board.setNextToPlay(player2);</span>
        else {
<span class="fc" id="L124">            board.setNextToPlay(player1);</span>
        }
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!board.isGameOver()) {</span>
<span class="fc" id="L127">            System.out.println(board.getNextToPlay().getPlayerName() + &quot; turn&quot;);</span>
<span class="fc" id="L128">            ui.printUserMessage(board.getNextToPlay().getPlayerName() + &quot; turn&quot;);</span>
        }
<span class="fc" id="L130">        ui.setVisible(true);</span>
        
        // if instance created with move delay, sleep for specified delay
        
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (testSleep != 0) {</span>
            try {
<span class="fc" id="L136">                Thread.sleep(testSleep);</span>
<span class="nc" id="L137">            } catch (InterruptedException ex) {</span>
                ;  // do nothing for now
<span class="fc" id="L139">            }</span>
        }
<span class="fc" id="L141">    }</span>
    
    // Following routines are for JUnit testing
    
    /**
     * For Junit testing - true if player (represented by symbol) won
     * @param symbol - player symbol to check
     * @return - true, if specified player won, otherwise false
     */
    public Boolean isWinner(Board.Symbols symbol) {
<span class="fc" id="L151">        System.out.println(&quot;**CHECKING WIN - isWinner(&quot; + symbol + &quot;) - returned&quot; + board.isWinner(symbol));</span>
<span class="fc" id="L152">        return (board.isWinner (symbol));</span>
    }
    
    /**
     * For Junit testing - true if game is a draw
     * @return - true if game ended as a draw, otherwise false
     */
    public Boolean isDraw() {
<span class="nc" id="L160">        return (board.isDraw ());</span>
    }
    
    /**
     * For Junit testing - reset board, also resets GUI &lt;br&gt;
     * ToDo - if no GUI, call board reset directly, don't call UI
     */
    public void resetBoard() {
<span class="fc" id="L168">        ui.resetGame();</span>
<span class="fc" id="L169">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>